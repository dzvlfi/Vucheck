# -*- coding: utf-8 -*-
"""MCP Vulnerability Check.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OYJZZv-r-bEVo84Rfd_dIOvm4ww_BkI3
"""

!pip install mcp openai

# Apply nest_asyncio to allow nested use of asyncio.run in notebooks
import nest_asyncio
nest_asyncio.apply()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mcp_vucheck.py
# 
# # Import standard libraries
# import asyncio                              # For asynchronous execution
# from typing import Optional                # For optional type hints
# from contextlib import AsyncExitStack      # To manage async context managers
# import os
# import json                                # For reading configuration
# import requests                            # For HTTP requests to the CVE API
# 
# # Import third-party libraries
# from mcp import ClientSession, StdioServerParameters
# from mcp.client.stdio import stdio_client
# from openai import OpenAI                  # OpenAI SDK for interacting with GPT
# 
# # Load configuration from config.json
# with open("config.json", "r") as json_file:
#     config = json.load(json_file)
# 
# # Extract configuration values
# OPENAI_API_KEY = config["OPENAI_API_KEY"]
# SLACK_BOT_TOKEN = config["SLACK_BOT_TOKEN"]
# SLACK_TEAM_ID = config["SLACK_TEAM_ID"]
# SLACK_CHANNELID_ALL = config["SLACK_CHANNELID_ALL"]
# CVE_ACCESS_TOKEN = config["CVE_ACCESS_TOKEN"]
# 
# # Main class for handling Slack integration and CVE intelligence
# class MCPClient:
#     def __init__(self):
#         self.session: Optional[ClientSession] = None
#         self.exit_stack = AsyncExitStack()                        # Handles async resource cleanup
#         self.client = OpenAI(api_key=OPENAI_API_KEY)             # Initialize OpenAI client
# 
#     # Establish connection to the MCP Slack server
#     async def connect_to_server(self):
#         server_params = StdioServerParameters(
#             command="npx",
#             args=["-y", "@modelcontextprotocol/server-slack"],   # MCP Slack server command
#             env={"SLACK_BOT_TOKEN": SLACK_BOT_TOKEN, "SLACK_TEAM_ID": SLACK_TEAM_ID},
#         )
# 
#         # Launch server and create client session
#         stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))
#         self.stdio, self.write = stdio_transport
# 
#         self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))
#         await self.session.initialize()  # Initialize the MCP session
# 
#         # Print available tools on the server
#         response = await self.session.list_tools()
#         tools = response.tools
#         print("\nConnected to server with tools:", [tool.name for tool in tools])
# 
#     # Query CVE Details API and summarize with GPT
#     async def vulncheck(self, product_name):
#         try:
#             # Prepare request to CVE API
#             url = f"https://www.cvedetails.com/api/v1/vulnerability/search?outputFormat=json&productName={product_name}&pageNumber=1&resultsPerPage=10"
#             headers = {
#                 "Authorization": f"Bearer {CVE_ACCESS_TOKEN}",
#                 "Accept": "*/*"
#             }
# 
#             response = requests.get(url, headers=headers)
#             cve_data = response.json()
# 
#             print("üîç Raw CVE data:")
#             print(cve_data)
# 
#             # Construct GPT query with structured output instruction
#             vulncheckQuery = [{
#                 "role": "user",
#                 "content": f"""
#                   You are a cybersecurity intelligence agent.
# 
#                   Your task is to summarize the following vulnerability data: "{cve_data}"
# 
#                   *Output Format*
# 
#                   *Product Name:* {{matched_product_name}}
#                   *Total CVEs:* {{total_cves}}
#                   *Risk Score (Avg CVSS):* {{average_risk_score}}
#                   *Product Type:* {{product_type}}
# 
#                   ---
# 
#                   *Top CVEs (Max 5)*
# 
#                   1. *CVE ID:* {{cve_id_1}}
#                     *CVSS Score:* {{cvss_score_1}}
#                     *Description:* {{cve_description_1}}
# 
#                   2. *CVE ID:* {{cve_id_2}}
#                     *CVSS Score:* {{cvss_score_2}}
#                     *Description:* {{cve_description_2}}
#                 """
#             }]
# 
#             response = self.client.chat.completions.create(
#                 model="gpt-4",
#                 messages=vulncheckQuery
#             )
# 
#             vulncheck = response.choices[0].message.content.strip()
#             print("\n‚úÖ Vulnerability Summary:")
#             print(vulncheck)
#             return vulncheck
# 
#         except Exception as e:
#             print(f"‚ùå Error during CVE summarization: {str(e)}")
# 
#     # Post summarized vulnerabilities to Slack
#     async def post_message(self, vulncheck):
#         try:
#             await self.session.call_tool("slack_post_message", {
#                 "channel_id": SLACK_CHANNELID_ALL,
#                 "text": vulncheck
#             })
#             print("‚úÖ Message posted to Slack successfully.")
#         except Exception as e:
#             print(f"‚ùå Error posting message: {str(e)}")
# 
#     # Clean up resources on exit
#     async def cleanup(self):
#         await self.exit_stack.aclose()
# 
# # Main execution function for the client workflow
# async def main():
#     client = MCPClient()
# 
#     try:
#         await client.connect_to_server()                          # Step 1: Connect to Slack via MCP
#         product_name = input("üîß Input Product Name: ").strip()   # Step 2: Get user input
#         checkresult = await client.vulncheck(product_name)        # Step 3: Query & summarize CVEs
#         await client.post_message(checkresult)                    # Step 4: Post result to Slack
#     finally:
#         await client.cleanup()                                    # Step 5: Clean up resources
# 
# # Entry point
# if __name__ == "__main__":
#     asyncio.run(main())
#

!python mcp_vucheck.py